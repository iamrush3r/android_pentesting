# android_pentesting


## Android Application Penetration Testing - Basics
### Reverse Engineering
  1. Reversing Android Apps in very easy.
  2. If the source code is obfuscated, reading the decompiled code can be challenging.
  3. Many tools are available.
  4. Depending on what we want to do, we can use different techniques:
     - Read and understand app's logic : **dex2jar & JD_GUI**
     - Modify the app : **apktool**
- **APK Tool**
  1. A great tool for disassembling and patching android apps
  2. We will get smali code
  3. We can also get readable AndroidManifest.xml
  4. Requires JDK
     - https://www.oracle.com/java/technologies/javase-downloads.html
  5. APK Tool installation instructions can be found at:
     - https://ibotpeaches.github.io/Apktool/install/
  6. **Test APK Tool**
       - ```apktool d SecureStore.apk```
       - This will create a folder with the APK name with all the files.
       - **smali** folder contains assembled code.
       - make all the required changes in the folder and patch it again using ```apktook b FolderName```
       - The patched APK will be available at ```FolderName/dist/```
- In Android 6 or higher, we need to ask for permissions at runtime.

- **dex2jar & JD-GUI**
  1. Great for viewing the source code from an APK file.
  2. **dex2jar**:
     - https://github.com/pxb1988/dex2jar
     - ```.\d2j-dex2jar.bat .\SecureStorev1.apk```
  3. **JD-GUI**:
     - https://java-decompiler.github.io/
   

### Traffic Analysis
1. Most of the apps use HTTP/HTTPS communications.
2. Redirect App's traffic to a proxy tool such as BurpSuite.
3. If HTTPS is used, burp's root CA needs to be installed on the device.
4. In some cases, we will have to deal with SSL Pinning.
5. If an application targets SDK higher or equal to 24, only the system certificates are trusted.
6. In build.gradle file targetSdkVersion 24.
7. This means, user installed certificates are ignored, and we cannot intercept SSL traffic of the app by default.
8. Three ways to bypass this:
   - Patch the application to trust user installed certificates.
   - Place user certificates in system certificate container.
   - Third way is to manipulate the app's runtime.
9. IP Address to use for proxy in emulator : ```10.0.2.2```.
10. For HTTPS traffic, install the burp certificate in emulator, if the ```.der``` file is grayed out, then convert it to ```.pem``` file using ```openssl x509 -inform der -in cacert.der -out cacert.pem```.
11. Push the certificate to android using ```adb push ./cacert.pem /mnt/sdcard/```.
12. Now even though we have inserted our CA Cert, it won't intercept any HTTPS traffic.
13. For this to bypass, we need to modify/patch the APK.
14. Deassemble the file using ```apktool d ./file.APK```.
15. Search for the ```AndroidManifest.xml``` file, and then in that file search for ```networkSecurityConfig```. It will have some file name after it.
16. In my case it's ```@xml/network_security_config```. Search for the ```network_security_config``` file, in my case it was found at ```./res/xml/```.
17. Add ```**user**``` as the source certificate. e.g. ```<certificates src="user" />```.
18. Now rebuild the APK file using ```apktool b ./folder```.
19. Even after this, you won't be able to install that application in ```./dist``` on emulator, because it is not signed yet. 
### Use Keytool (java) to generate a key and use jarSigner to sign the application
1. Geneate key using ```keytool -genkey -v -keystore mysigning.keystore -alias securestore -keyalg RSA -keysize 2048 -validity 10000```
2. Sign the APK with the key generated using ```jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore mysigning.keystore .\SecureStorev2_noroot.apk securestore```
